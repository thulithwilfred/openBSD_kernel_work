? cscope.out
? microcode/atmel/atu-at76c503-i3863-ext
? microcode/atmel/atu-at76c503-i3863-int
? microcode/atmel/atu-at76c503-rfmd-acc-ext
? microcode/atmel/atu-at76c503-rfmd-acc-int
? microcode/atmel/atu-at76c505-rfmd-ext
? microcode/atmel/atu-at76c505-rfmd-int
? microcode/atmel/atu-intersil-ext
? microcode/atmel/atu-intersil-int
? microcode/atmel/atu-rfmd-ext
? microcode/atmel/atu-rfmd-int
? microcode/atmel/atu-rfmd2958-ext
? microcode/atmel/atu-rfmd2958-int
? microcode/atmel/atu-rfmd2958smc-ext
? microcode/atmel/atu-rfmd2958smc-int
? microcode/atmel/build
? microcode/atmel/build.d
? microcode/bnx/bnx-b06
? microcode/bnx/bnx-b09
? microcode/bnx/bnx-rv2p
? microcode/bnx/bnx-xi-rv2p
? microcode/bnx/bnx-xi90-rv2p
? microcode/bnx/build
? microcode/bnx/build.d
? microcode/cirruslogic/build
? microcode/cirruslogic/build.d
? microcode/cirruslogic/cs4280
? microcode/fxp/build
? microcode/fxp/build.d
? microcode/fxp/fxp-d101a
? microcode/fxp/fxp-d101b0
? microcode/fxp/fxp-d101ma
? microcode/fxp/fxp-d101s
? microcode/fxp/fxp-d102
? microcode/fxp/fxp-d102c
? microcode/fxp/fxp-d102e
? microcode/kue/build
? microcode/kue/build.d
? microcode/kue/kue
? microcode/myx/build
? microcode/myx/build.d
? microcode/myx/myx-eth_z8e
? microcode/myx/myx-ethp_z8e
? microcode/ral/build
? microcode/ral/build.d
? microcode/ral/ral-rt2561
? microcode/ral/ral-rt2561s
? microcode/ral/ral-rt2661
? microcode/ral/ral-rt2860
? microcode/ral/ral-rt3290
? microcode/rum/build
? microcode/rum/build.d
? microcode/rum/rum-rt2573
? microcode/rum/run-rt2870
? microcode/rum/run-rt3071
? microcode/tht/build
? microcode/tht/build.d
? microcode/tht/tht
? microcode/tigon/build
? microcode/tigon/build.d
? microcode/tigon/tigon1
? microcode/tigon/tigon2
? microcode/tusb3410/build
? microcode/tusb3410/build.d
? microcode/tusb3410/tusb3410
? microcode/typhoon/3c990
? microcode/typhoon/build
? microcode/typhoon/build.d
? microcode/udl/build
? microcode/udl/build.d
? microcode/udl/udl_huffman
? microcode/yds/build
? microcode/yds/build.d
? microcode/yds/yds
? microcode/zydas/build
? microcode/zydas/build.d
? microcode/zydas/zd1211
? microcode/zydas/zd1211b
Index: acct.c
===================================================================
RCS file: acct.c
diff -N acct.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ acct.c	21 Sep 2021 13:05:40 -0000
@@ -0,0 +1,1230 @@
+/**
+ * @file acct.c 
+ * @author Thulith Wilfred (thulith.mallawa@uqconnect.edu.au)
+ * @brief Process and File accounting device driver for OpenBSD
+ * @version 1.0
+ * @date 2021-09-13
+ * 
+ * @copyright Copyright (c) 2021
+ * 
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/types.h>
+#include <sys/conf.h>
+#include <sys/poll.h>
+#include <sys/types.h>
+#include <sys/malloc.h>
+#include <sys/filio.h>
+#include <sys/fcntl.h>
+#include <sys/proc.h>
+
+#include <sys/rwlock.h>
+#include <sys/tty.h>
+
+#include <sys/time.h>
+#include <sys/kernel.h>
+#include <sys/resourcevar.h>
+
+#include <sys/namei.h>
+#include <sys/vnode.h>
+
+#include <sys/tree.h>
+
+#include "acct.h"
+//TODO STYLE BRUH
+/* Local Defines */
+#define ALL_OFF 	0x00		/* Set audit status, all off */
+#define RDWR_MODE_OK 	1 		/* Current mode is RDWR Mode */
+#define RDWR_MODE_NON	0
+#define FILE_ENA_MASK 	0x78		/* Bitmask to force set of file fork/exec/exit */
+
+/* Globals 
+ * The following members should be operated on atomically.
+ */
+int rdwr_mode = 0;			/* Is the device opened in RDWR mode */
+int sequence_num = 0;			/* Current sequence number for a message */
+int open_status = 0; 			/* Is the device currently opened */
+int device_opened = 0;			/* Is the device currently opened */
+int fcount = 0;				/* Tracked file count */
+uint32_t acct_audit_stat = ALL_OFF;	/* Starting global flags */
+ 
+
+/* TailQ Data Structures */
+
+/* 
+ * The following union allows for a single message to be enqueed into the message queue (TAILQ),
+ * the sender must set the type field of struct message and the receiver must read the type field of struct message to verify data types
+ */
+union message_data {
+	struct acct_fork fork_d;
+	struct acct_exec exec_d;
+	struct acct_exit exit_d;
+	struct acct_open open_d;
+	struct acct_rename rename_d;
+	struct acct_unlink unlink_d;
+	struct acct_close close_d;
+};
+
+
+/* Message queue that holds event messages */
+struct message {
+	TAILQ_ENTRY(message) entries;
+	int type; 				/* Defines type of data the message is, i.e struct acct_fork relates to ACCT_MSG_FORK*/
+	unsigned int size; 			/* Total size of the data held by 'data' in bytes, set by sender */
+	union message_data data;		/* acct message */
+};
+
+/* Red black tree that holds tracking file vnodes */
+struct tree_node {
+	RB_ENTRY(tree_node) tree_entry;
+	struct vnode *v;			/* Holds a tracked files vnode red */
+	char path[PATH_MAX];			/* Holds path */
+	uint32_t audit_events;			/* File enabled events */
+	uint32_t audit_conds;			/* Audit conditions set for the tracking file */
+};
+
+
+/* Local Functions */
+int resolve_vnode(const char*, struct proc *, struct vnode **);
+int vnode_cmp(struct tree_node *, struct tree_node *);
+int add_node_to_tree(struct vnode *, uint32_t *, uint32_t *, const char *);
+void free_traversed_vnodes(struct nameidata *);
+int untrack_from_tree(struct vnode *, uint32_t *, uint32_t *);
+int drop_all_files(void);
+int update_from_tree(struct vnode *, uint32_t *, uint32_t *);
+bool acct_this_message(uint32_t, uint32_t, int);
+bool acct_conds_ok(uint32_t, uint32_t);
+bool acct_mode_ok(uint32_t, int);
+
+/* Initializers */
+/* RW Lock */
+struct rwlock rwl = RWLOCK_INITIALIZER("acct_lock");
+
+TAILQ_HEAD(message_queue, message) head; 		
+
+RB_HEAD(vnodetree, tree_node) rb_head = RB_INITIALIZER(&rb_head);
+RB_PROTOTYPE(vnodetree, tree_node, tree_entry, vnode_cmp);
+RB_GENERATE(vnodetree, tree_node, tree_entry, vnode_cmp);
+
+/**
+ * @brief Node comparison used to compare trees' nodes with each other
+ * 	If the first argument is smaller than the second, the function returns a value smaller 
+ * 	than zero. If they are equal, the function returns zero.
+ * 
+ *  Otherwise, it should return a value greater than zero.
+ *  The compare function defines the order of the tree elements
+ * 
+ * @param v1 node 1
+ * @param v2 node 2
+ * @return * Node 
+ */
+int
+vnode_cmp(struct tree_node *node1, struct tree_node *node2)
+{
+	return (node1->v->v_id < node2->v->v_id ? -1 : node1->v->v_id > node2->v->v_id);
+}
+
+
+/**
+ * @brief Initialise state required for operations 
+ * 
+ */
+int
+acctattach(int num) 
+{
+	/* Initialise the message queue for acct messages */
+	TAILQ_INIT(&head);
+
+	/* Clear Audit Stats */
+	rw_enter_write(&rwl);
+	acct_audit_stat = ALL_OFF;
+	sequence_num = 0;
+	open_status = 0;
+	rdwr_mode = 0;
+	device_opened = 0;
+	fcount = 0;	
+	rw_exit_write(&rwl);
+
+	return (0);
+}
+
+int
+acctopen(dev_t dev, int flag, int mode, struct proc *p)
+{
+	/* Allow only 0th minor to be opened */
+	if (minor(dev) != 0)
+		return (ENXIO);
+
+	if (device_opened)
+		return (EBUSY);
+
+	flag = OFLAGS(flag);
+
+	/* If not opened exclusively */
+	if ((flag & O_EXLOCK) == 0)
+		return ENODEV;
+
+	/* If not opened with O_RDONLY or O_RDWR */
+	if (flag & O_WRONLY)
+		return (EPERM);
+
+	/* Set the mode in which the device was opened for, only care about if RDWR */
+	if (flag & O_RDWR)
+		rdwr_mode = RDWR_MODE_OK; 
+	else 
+		rdwr_mode = RDWR_MODE_NON;
+	
+	/* Reset Sequence Num */
+	rw_enter_write(&rwl); /* The lock is probably not needed here? */
+	sequence_num = 0;
+	device_opened = 1;
+	rw_exit_write(&rwl);
+
+	return (0);
+}
+
+
+
+int 
+acctread(dev_t dev, struct uio *uio, int flags)
+{
+	struct message *acct_msg;
+	int err;
+
+	rw_enter_read(&rwl);
+
+	if (TAILQ_EMPTY(&head)) {
+		/* Data not ready, wake me up when ready... */
+		err = rwsleep(&head, &rwl, PWAIT | PCATCH ,"Waiting for events", 0);
+
+		/* Interuppted by sys call or returning from signal */
+		if ((err == EINTR) || (err == ERESTART)) {
+			rw_exit_read(&rwl);
+			return (err);						
+		}
+
+		/* Processes returning from sleep should always re-evaluate the conditions */
+		if (TAILQ_EMPTY(&head))  {
+			rw_exit_read(&rwl); 		
+			return EIO;
+		}
+	} 
+
+	/* Processes returning from sleep should always re-evaluate the conditions */
+	if (TAILQ_EMPTY(&head))  {
+		rw_exit_read(&rwl); 		
+		return EIO;
+	}
+
+	/* Get next message from queue */
+	acct_msg = TAILQ_FIRST(&head);
+
+	err = uiomove((void*)&acct_msg->data, acct_msg->size, uio);
+
+	if (err) {
+		/* uiomove failed */
+		TAILQ_REMOVE(&head, acct_msg, entries);
+		free(acct_msg, M_DEVBUF, sizeof(struct message));
+		rw_exit_read(&rwl);
+		return (EFAULT);
+	}
+
+	/* Uiomove succeeded, clear message from queue */
+	TAILQ_REMOVE(&head, acct_msg, entries);
+	free(acct_msg, M_DEVBUF, sizeof(struct message));
+	rw_exit_read(&rwl);
+	return 0;
+}
+
+/**
+ * @brief Set the audit stats 
+ * 
+ * @param set_mask bit fields to be set 
+ */
+void
+set_audit_stats(uint32_t set_mask) 
+{
+	acct_audit_stat |= set_mask;
+}
+
+/**
+ * @brief Clear the audit stats 
+ * 
+ * @param set_mask bit fields to be cleared
+ */
+void clear_audit_stats(uint32_t clear_mask)
+{
+	acct_audit_stat &= ~(clear_mask);
+}
+
+int 
+acctioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
+{
+	struct acct_ctl *ctl;
+	struct vnode *vn;
+	struct message *next_msg;
+	const char* pathname;
+	uint32_t file_ena_mask;
+
+
+	/* Support for generic ioctl requests */
+	switch(cmd) {
+	case FIONREAD:
+		/* Get the number of bytes that are immediately available for reading */
+		rw_enter_read(&rwl);
+		if (TAILQ_EMPTY(&head)) {
+			*(int *)data = 0; 			/* Queue is empty, nothing to read */
+		} else {
+			next_msg = TAILQ_FIRST(&head); 		/* Next available message FIFO */
+			*(int *)data = next_msg->size;
+		}
+		rw_exit_read(&rwl);
+		return (0);
+	case FIONBIO:
+		/*  Handled in the upper FS layer */
+		if (*(int *)data != 0) 				/* Attempting to set non-blocking, miss me with that... */
+			return (EOPNOTSUPP);
+	case FIOASYNC:
+		return (EOPNOTSUPP);
+	}
+
+	/* Device specific ioctls not accepted in read only mode */
+	if (rdwr_mode != RDWR_MODE_OK) 
+	 	return (ENOTTY); 
+
+	ctl = (struct acct_ctl*)data;
+
+	/* Support for device specific ioctl requests */
+	switch(cmd) {
+	case ACCT_IOC_STATUS:
+		rw_enter_read(&rwl);
+		ctl->acct_ena = acct_audit_stat;		/* update with currently enabled features */
+		ctl->acct_fcount = fcount;					
+		rw_exit_read(&rwl);
+		break;
+	case ACCT_IOC_FSTATUS:
+		rw_enter_read(&rwl);
+		pathname = ctl->acct_path;
+
+		/* 1 Resolve vnode from path */
+		if (resolve_vnode(pathname, p, &vn) != 0) {
+			rw_exit_read(&rwl);
+			return ENOENT;				/* Unable to resolve */
+		}
+
+		if ((update_from_tree(vn, &ctl->acct_cond, &ctl->acct_ena) == ENOENT)){
+			rw_exit_read(&rwl);
+			return ENOENT;
+		}
+
+		rw_exit_read(&rwl);
+		break;
+	case ACCT_IOC_ENABLE:	
+		rw_enter_read(&rwl);	
+		set_audit_stats(ctl->acct_ena);			/* set features to enable */
+		ctl->acct_ena = acct_audit_stat;		/* update with currently enabled features */
+		rw_exit_read(&rwl);
+		break;
+	case ACCT_IOC_DISABLE:
+		rw_enter_read(&rwl);
+		clear_audit_stats(ctl->acct_ena);		/* set features to disable */
+		ctl->acct_ena = acct_audit_stat;		/* update with currently enabled features  */
+
+		file_ena_mask = (ACCT_ENA_OPEN | ACCT_ENA_CLOSE | ACCT_ENA_RENAME | ACCT_ENA_UNLINK);
+
+		if ((acct_audit_stat & (file_ena_mask)) == 0) {
+			/* Drop all files */
+			drop_all_files();
+		}
+
+		rw_exit_read(&rwl);
+		break;
+	case ACCT_IOC_TRACK_FILE:	
+		rw_enter_read(&rwl);
+		pathname = ctl->acct_path;
+		ctl->acct_ena &= FILE_ENA_MASK;			/* Disable fork/exec/exit */
+		/* 1 Resolve vnode from path */
+		if (resolve_vnode(pathname, p, &vn) != 0) {
+			rw_exit_read(&rwl);
+			return ENOENT;				/* Unable to resolve */
+		}
+
+		/* 
+		* 2 Vnode resolved, add to tracked tree
+		* 	 If file is already tracked, params are updated.
+		*/
+		if (add_node_to_tree(vn, &ctl->acct_cond, &ctl->acct_ena, pathname) == EEXIST) {
+			rw_exit_read(&rwl);
+			return (0);
+		}
+	
+		rw_exit_read(&rwl);
+		break;
+	case ACCT_IOC_UNTRACK_FILE:
+		rw_enter_read(&rwl);
+		pathname = ctl->acct_path;
+		ctl->acct_ena &= FILE_ENA_MASK;			/* Disable fork/exec/exit */
+
+		/* 1 Resolve vnode from path */
+		if (resolve_vnode(pathname, p, &vn) != 0) {
+			rw_exit_read(&rwl);
+			return ENOENT;				/* Unable to resolve */
+		}
+
+		/* 2 Attempt to untrack */
+		if (untrack_from_tree(vn, &ctl->acct_cond, &ctl->acct_ena) == ENOENT) {
+			rw_exit_read(&rwl);
+			return (ENOENT);			/* Not tracked */
+		}
+
+		rw_exit_read(&rwl);
+		break;
+	default:
+		return (ENOTTY); 				/* Inappropriate ioctl for device */
+	}
+	return (0);
+}
+
+int 
+update_from_tree(struct vnode *vn, uint32_t *ctl_conds, uint32_t *ctl_events) 
+{
+	struct tree_node *find_node, *res;
+
+	/* Copy ref to vnode and update set up file events/conds */
+	find_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	find_node->v = vn;
+
+	/* Test for matching v_id in tree */
+	res = RB_FIND(vnodetree, &rb_head, find_node);
+
+	free(find_node, M_DEVBUF, sizeof(struct tree_node));
+
+	if (res == NULL) {
+		/* File not tracked */
+		return (ENOENT);
+	}
+
+	/* Return remaining conditions */
+	*ctl_conds = res->audit_conds;
+	*ctl_events = res->audit_events;
+
+	return (0);
+}
+
+int
+drop_all_files(void) {
+	struct tree_node *res, *next;
+
+	RB_FOREACH_SAFE(res, vnodetree, &rb_head, next) {
+		/* Release ref to vnode */
+		vrele(res->v);
+		RB_REMOVE(vnodetree,  &rb_head, res);
+		free(res, M_DEVBUF, sizeof(struct tree_node));
+		fcount--;					
+	}
+	return (0);
+}
+
+int
+untrack_from_tree(struct vnode *vn, uint32_t *ctl_conds, uint32_t *ctl_events)
+{
+	struct tree_node *find_node, *res;
+
+	/* Copy ref to vnode and update set up file events/conds */
+	find_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	find_node->v = vn;
+
+	/* Test for matching v_id in tree */
+	res = RB_FIND(vnodetree, &rb_head, find_node);
+
+	free(find_node, M_DEVBUF, sizeof(struct tree_node));
+
+	if (res == NULL) {
+		/* File not tracked */
+		return (ENOENT);
+	}
+
+	/* Found a match, unset required params */
+	res->audit_conds &= ~(*ctl_conds);
+	res->audit_events &= ~(*ctl_events);
+
+	if ((res->audit_conds == 0) || (res->audit_events == 0)) {
+		/* Untrack file entirely */
+		*ctl_conds = 0;
+		*ctl_events = 0;
+		fcount--;	
+
+		/* Release ref to vnode */
+		vrele(res->v);
+		RB_REMOVE(vnodetree,  &rb_head, res);
+		free(res, M_DEVBUF, sizeof(struct tree_node));
+		return(0);
+	}
+
+	/* Return remaining conditions */
+	*ctl_conds = res->audit_conds;
+	*ctl_events = res->audit_events;
+	
+	return (0);
+}
+
+int
+add_node_to_tree(struct vnode *vn, uint32_t *ctl_conds, uint32_t *ctl_events, const char* pathname)
+{
+	struct tree_node *new_node, *res; 
+
+	/* Copy ref to vnode and update set up file events/conds */
+	new_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	new_node->v = vn;
+	new_node->audit_conds = *ctl_conds;
+	new_node->audit_events = *ctl_events;
+	
+	/* Save path */
+	memcpy(new_node->path, pathname, PATH_MAX);
+
+	/* Try add Vnode to tracked tree of vnodes, checks by v_id */
+	res = RB_INSERT(vnodetree, &rb_head, new_node);
+	
+	if (res != NULL) {
+		/* Matching element exists in tree */
+		res->audit_conds |= *ctl_conds;	
+		res->audit_events |= *ctl_events;
+
+		/* Update ctl params with existing ones */
+		*ctl_conds = res->audit_conds;
+		*ctl_events = res->audit_events;
+
+		free(new_node, M_DEVBUF, sizeof(struct tree_node));
+		return EEXIST;
+	}
+
+	/* Added new entry */
+	fcount++;	
+	return (0);
+}
+
+int 
+resolve_vnode(const char* u_pathname, struct proc *p, struct vnode **vn)
+{
+	struct nameidata nd;
+	int err = 0;
+
+	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF,
+    	UIO_SYSSPACE, u_pathname, p);
+
+	if ((err = namei(&nd)) != 0) {
+		free_traversed_vnodes(&nd);
+		return err;
+	}
+
+	/* Copy ref to resolved vnode */
+	*vn = nd.ni_vp;
+	
+    	/* release lock from namei, but keep ref to vnode */
+	if (nd.ni_vp)
+		VOP_UNLOCK(nd.ni_vp);
+
+	return (err);
+}
+
+/**
+ * @brief Refer to unveil_free_traversed_vnodes
+ * 
+ * @param ndp 
+ */
+void 
+free_traversed_vnodes(struct nameidata *ndp) 
+{
+	if (ndp->ni_tvpsize) {
+		size_t i;
+		
+		for (i = 0; i < ndp->ni_tvpend; i++)
+			vrele(ndp->ni_tvp[i]); /* ref for being in list */
+			
+		free(ndp->ni_tvp, M_PROC, ndp->ni_tvpsize *sizeof(struct vnode *));
+        	ndp->ni_tvpsize = 0;
+        	ndp->ni_tvpend = 0;
+	}
+}
+
+
+struct acct_common 
+construct_common(struct process *pdata, int type)
+{
+	struct timespec uptime, booted;
+	struct acct_common common;
+
+	/* 
+	 * Create message common fields 
+	 */
+
+	/* Sequence begins from index 0 */
+	common.ac_seq = sequence_num;
+	sequence_num++;
+
+	/* Set message type and data size */
+	switch (type) {
+	case ACCT_MSG_FORK:
+		common.ac_type = ACCT_MSG_FORK;	
+		common.ac_len = sizeof(struct acct_fork);
+		break;
+	case ACCT_MSG_EXEC:
+		common.ac_type = ACCT_MSG_EXEC;
+		common.ac_len = sizeof(struct acct_exec);			
+		break;
+	case ACCT_MSG_EXIT:
+		common.ac_type = ACCT_MSG_EXIT;	
+		common.ac_len = sizeof(struct acct_exit);		
+		break;
+	case ACCT_MSG_OPEN:
+		common.ac_type = ACCT_MSG_OPEN;	
+		common.ac_len = sizeof(struct acct_open);	
+		break;
+	case ACCT_MSG_RENAME:
+		common.ac_type = ACCT_MSG_RENAME;	
+		common.ac_len = sizeof(struct acct_rename);		
+		break;
+	case ACCT_MSG_UNLINK:
+		common.ac_type = ACCT_MSG_UNLINK;	
+		common.ac_len = sizeof(struct acct_unlink);	
+		break;
+	case ACCT_MSG_CLOSE:
+		common.ac_type = ACCT_MSG_CLOSE;	
+		common.ac_len = sizeof(struct acct_close);	
+		break;
+	}
+
+	/*  Get command name */
+	memcpy(common.ac_comm, pdata->ps_comm, sizeof(common.ac_comm));
+
+	/* Get Time */
+	nanouptime(&uptime);
+	nanoboottime(&booted);
+	timespecadd(&booted, &pdata->ps_start, &common.ac_btime);	/* Calculate and update start time */	
+	timespecsub(&uptime, &pdata->ps_start, &common.ac_etime); 	/* Calculate and update elapsed time*/
+
+	/* Get Ids */
+	common.ac_pid = pdata->ps_ppid;								
+	common.ac_uid = pdata->ps_ucred->cr_uid;
+	common.ac_gid = pdata->ps_ucred->cr_gid;
+
+	/* Get Controlling TTY */
+	if ((pdata->ps_flags & PS_CONTROLT) && pdata->ps_pgrp->pg_session->s_ttyp)
+		common.ac_tty = pdata->ps_pgrp->pg_session->s_ttyp->t_dev;
+	else 
+		common.ac_tty = NODEV;
+
+	/* Get Accounting flags */
+	common.ac_flag = pdata->ps_acflag;
+
+	return common;
+}
+
+void
+acct_fork(struct process *pr) 
+{
+	struct message *acct_msg;
+
+	/* if fork accounting not enabled or device closed, let's not worry about this... */
+	rw_enter_read(&rwl);
+	if(device_opened == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	if((acct_audit_stat & ACCT_ENA_FORK) == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+	
+	rw_exit_read(&rwl);
+
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO); 
+	
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_FORK;
+	acct_msg->size = sizeof(struct acct_fork);
+
+	/* Update message common fields within this message */
+	rw_enter_read(&rwl);
+	/* Common message based on parent info */
+	acct_msg->data.fork_d.ac_common = construct_common(pr->ps_pptr, ACCT_MSG_FORK);	
+	/* Set child pid */
+	acct_msg->data.fork_d.ac_cpid = pr->ps_pid;		/* Child process id */
+	rw_exit_read(&rwl);
+
+	/* Enqueue Data */
+	rw_enter_write(&rwl);
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	rw_exit_write(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+} 
+
+void
+acct_exec(struct process *pr)
+{
+	struct message *acct_msg;
+
+	/* if fork accounting not enabled or device closed, let's not worry about this... */
+	rw_enter_read(&rwl);
+	
+	if(device_opened == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	if((acct_audit_stat & ACCT_ENA_EXEC) == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	rw_exit_read(&rwl);
+
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO);
+
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_EXEC;
+	acct_msg->size = sizeof(struct acct_exec);
+
+	/* Update message common fields within this message */
+	rw_enter_read(&rwl);
+	acct_msg->data.exec_d.ac_common = construct_common(pr, ACCT_MSG_EXEC);
+	rw_exit_read(&rwl);
+
+	/* Enqueue Data */
+	rw_enter_write(&rwl);
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	rw_exit_write(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+}
+
+void
+acct_exit(struct process *pr)
+{
+	struct timespec ut, st, tmp;
+	struct message *acct_msg;
+	struct rusage *r;
+	int t;
+
+	/* if exit accounting not enabled or device closed, let's not worry about this... */
+	rw_enter_read(&rwl);
+
+	if(device_opened == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	if((acct_audit_stat & ACCT_ENA_EXIT) == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	rw_exit_read(&rwl);
+
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO);
+	
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_EXIT;
+	acct_msg->size = sizeof(struct acct_exit);
+
+	/* Update message common fields within this message */
+	rw_enter_read(&rwl);
+	acct_msg->data.exit_d.ac_common = construct_common(pr, ACCT_MSG_EXIT);
+
+	/* 
+	 * Set exit struct additional data 
+	 */
+	
+	/* User & sys Time */
+	calctsru(&pr->ps_tu, &ut, &st, NULL);
+	
+	acct_msg->data.exit_d.ac_utime = ut;
+	acct_msg->data.exit_d.ac_stime = st;
+
+	/* Avg memory usage */
+	r = &pr->ps_mainproc->p_ru;
+	timespecadd(&ut, &st, &tmp);
+	t = tmp.tv_sec * hz + tmp.tv_nsec / (1000 * tick); 		/* hz and tick are sys externs */
+
+	if (t)
+		acct_msg->data.exit_d.ac_mem = (r->ru_ixrss + r->ru_idrss + r->ru_isrss) / t;
+	else
+		acct_msg->data.exit_d.ac_mem = 0;
+
+	/* I/O ops count */
+	acct_msg->data.exit_d.ac_io = r->ru_inblock + r->ru_oublock;
+	rw_exit_read(&rwl);
+
+	/* Enqueue Data */
+	rw_enter_write(&rwl);
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	rw_exit_write(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+}
+
+
+void
+acct_close(struct process *pr, struct vnode *vn_cmp, u_int f_flag) 
+{
+	struct message *acct_msg;
+	struct tree_node *find_node, *res;
+	u_int o_flags = OFLAGS(f_flag);
+	uint32_t f_events, f_conds;			/* File Unique events */
+	
+	/* Device not opened, no need to queue anything */
+	rw_enter_read(&rwl);
+
+	if (device_opened == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	/* If open accounting disabled, we outchea ... */ 
+	if ((acct_audit_stat & ACCT_ENA_CLOSE) == 0) {
+		rw_exit_read(&rwl);
+		return;		
+	}
+
+	/* Incase a vnode wasn't resolved */
+	if(vn_cmp == NULL) {
+		rw_exit_read(&rwl);
+		return;						
+	}
+
+	/* This file currently tracked ? */
+	find_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	find_node->v = vn_cmp;
+
+	/* Test for matching v_id in tree */
+	res = RB_FIND(vnodetree, &rb_head, find_node);
+
+	free(find_node, M_DEVBUF, sizeof(struct tree_node));
+
+	if (res == NULL) {
+		rw_exit_read(&rwl);
+		return;  			/* We aren't tracking this */
+	}
+
+	/* File conditions match the open call? */
+	f_events = res->audit_events;
+	f_conds = res->audit_conds;
+
+	/* File doesn't have close accounting set */
+	if ((f_events & ACCT_ENA_CLOSE) == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+
+	if (acct_conds_ok(f_conds, o_flags) == false) {
+		rw_exit_read(&rwl);	 
+		return;				/* Condition mismatch */
+	}
+
+	/* Construct message */
+
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO);
+
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_CLOSE;
+	acct_msg->size = sizeof(struct acct_close);
+
+	/* Update message common fields within this message */
+	acct_msg->data.close_d.ac_common = construct_common(pr, ACCT_MSG_CLOSE);
+
+	/* Update Open message specific fields */
+	memcpy(acct_msg->data.close_d.ac_path, res->path, PATH_MAX);
+
+	/* Add to queue */
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	rw_exit_read(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+	return;
+}
+
+void
+remove_from_tree(struct tree_node *res)
+{
+	/* Release ref to vnode */
+	vrele(res->v);
+	RB_REMOVE(vnodetree,  &rb_head, res);
+	free(res, M_DEVBUF, sizeof(struct tree_node));
+}
+
+
+void 
+acct_unlink(struct process *pr, struct vnode *vn_cmp, int err)
+{
+	struct message *acct_msg;
+	struct tree_node *find_node, *res;
+	uint32_t f_events, f_conds;			/* File Unique events */
+
+	/* Device not opened, no need to queue anything */
+	rw_enter_read(&rwl);
+
+	/* Avert bamboozle */
+	if(vn_cmp == NULL) {
+		rw_exit_read(&rwl);
+		return;						
+	}
+
+	/* This file currently tracked ? */
+	find_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	find_node->v = vn_cmp;
+
+	/* Test for matching v_id in tree */
+	res = RB_FIND(vnodetree, &rb_head, find_node);
+
+	free(find_node, M_DEVBUF, sizeof(struct tree_node));
+
+	if (res == NULL) {
+		rw_exit_read(&rwl);
+		return;  			/* We aren't tracking this */
+	}
+
+	/* At this point the file is tracked, so drop it before we return */
+	fcount--;
+
+	/* Unlink acct globally disabled */
+	if ((acct_audit_stat & ACCT_ENA_UNLINK) == 0) {	
+		remove_from_tree(res);
+		rw_exit_read(&rwl);
+		return;		
+	}
+
+	/* Device not opened, no need to queue anything */
+	if (device_opened == 0) {
+		remove_from_tree(res);
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	/* File conditions match the open call? */
+	f_events = res->audit_events;
+	f_conds = res->audit_conds;
+
+	/* File doesn't have unlink accounting set */
+	if ((f_events & ACCT_ENA_UNLINK) == 0) {
+		remove_from_tree(res);
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	if (acct_mode_ok(f_conds, err) == false) {
+		remove_from_tree(res);
+		rw_exit_read(&rwl);	 
+		return;				/* Succes/Failure condition mismatch */
+	}
+
+	/* Construct message */
+	
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO);
+
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_UNLINK;
+	acct_msg->size = sizeof(struct acct_unlink);
+
+	/* Update message common fields within this message */
+	acct_msg->data.unlink_d.ac_common = construct_common(pr, ACCT_MSG_UNLINK);
+
+	/* Update Rename message specific fields */
+	memcpy(acct_msg->data.unlink_d.ac_path, res->path, PATH_MAX);
+	acct_msg->data.unlink_d.ac_errno = err;
+
+	/* Add to queue */
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	remove_from_tree(res);			/* Removing since unlink event */
+	rw_exit_read(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+	return;
+}
+
+void
+acct_rename(struct process *pr, struct vnode *vn_cmp, const char *new_path, int err) 
+{
+	struct message *acct_msg;
+	struct tree_node *find_node, *res;
+	uint32_t f_events, f_conds;			/* File Unique events */
+
+	
+	rw_enter_read(&rwl);
+
+	/* Avert bamboozle */
+	if(vn_cmp == NULL) {
+		rw_exit_read(&rwl);
+		return;						
+	}
+
+	/* This file currently tracked ? */
+	find_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	find_node->v = vn_cmp;
+
+	/* Test for matching v_id in tree */
+	res = RB_FIND(vnodetree, &rb_head, find_node);
+
+	free(find_node, M_DEVBUF, sizeof(struct tree_node));
+
+	if (res == NULL) {
+		rw_exit_read(&rwl);
+		return;  			/* We aren't tracking this */
+	}
+
+	/* At this point the file is tracked, so drop it before we return */
+	fcount--;
+
+	/* Rename acct globally disabled */
+	if ((acct_audit_stat & ACCT_ENA_RENAME) == 0) {	
+		remove_from_tree(res);
+		rw_exit_read(&rwl);
+		return;		
+	}
+
+	/* Device not opened, no need to queue anything */
+	if (device_opened == 0) {
+		remove_from_tree(res);
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	/* File conditions match the open call? */
+	f_events = res->audit_events;
+	f_conds = res->audit_conds;
+
+	/* File doesn't have rename accounting set */
+	if ((f_events & ACCT_ENA_RENAME) == 0) {
+		remove_from_tree(res);
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	if (acct_mode_ok(f_conds, err) == false) {
+		remove_from_tree(res);
+		rw_exit_read(&rwl);	 
+		return;				/* Succes/Failure condition mismatch */
+	}
+
+	/* Construct message */
+	
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO);
+
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_RENAME;
+	acct_msg->size = sizeof(struct acct_rename);
+
+	/* Update message common fields within this message */
+	acct_msg->data.rename_d.ac_common = construct_common(pr, ACCT_MSG_RENAME);
+
+	/* Update Rename message specific fields */
+	/* sys_call userspace string -> kernel, causes (random) pagefaults else */
+	copyinstr(new_path, acct_msg->data.rename_d.ac_new, PATH_MAX, NULL);
+	memcpy(acct_msg->data.rename_d.ac_path, res->path, PATH_MAX);
+	
+	acct_msg->data.rename_d.ac_errno = err;
+
+	/* Add to queue */
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	remove_from_tree(res);			/* Removing since rename event */
+	rw_exit_read(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+	return;
+}
+
+void
+acct_open(struct process *pr, struct vnode *vn_cmp, int o_flags, int err) 
+{
+	struct message *acct_msg;
+	struct tree_node *find_node, *res;
+	uint32_t f_events, f_conds;			/* File Unique events */
+
+	/* Device not opened, no need to queue anything */
+	rw_enter_read(&rwl);
+
+	if (device_opened == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	/* If open accounting disabled, we outchea ... */
+	if ((acct_audit_stat & ACCT_ENA_OPEN) == 0) {
+		rw_exit_read(&rwl);
+		return;		
+	}
+
+	/* Incase a vnode wasn't resolved */
+	if(vn_cmp == NULL) {
+		rw_exit_read(&rwl);
+		return;						
+	}
+
+	/* This file currently tracked ? */
+	find_node = malloc(sizeof(struct tree_node),  M_DEVBUF, M_WAITOK | M_ZERO);
+	find_node->v = vn_cmp;
+
+	/* Test for matching v_id in tree */
+	res = RB_FIND(vnodetree, &rb_head, find_node);
+
+	free(find_node, M_DEVBUF, sizeof(struct tree_node));
+
+	if (res == NULL) {
+		rw_exit_read(&rwl);
+		return;  			/* We aren't tracking this */
+	}
+
+	/* File conditions match the open call? */
+	f_events = res->audit_events;
+	f_conds = res->audit_conds;
+
+	/* File doesn't have open accounting set */
+	if ((f_events & ACCT_ENA_OPEN) == 0) {
+		rw_exit_read(&rwl);
+		return;
+	}
+
+	if (acct_this_message(f_conds, o_flags, err) == false) {
+		rw_exit_read(&rwl);	 
+		return;				/* Condition mismatch */
+	}
+
+	/* Construct message */
+
+	/* Commited to processing the message now... */
+	acct_msg = malloc(sizeof(struct message), M_DEVBUF, M_WAITOK | M_ZERO);
+
+	/* Set internal message data */
+	acct_msg->type = ACCT_MSG_OPEN;
+	acct_msg->size = sizeof(struct acct_open);
+
+	/* Update message common fields within this message */
+	acct_msg->data.open_d.ac_common = construct_common(pr, ACCT_MSG_OPEN);
+
+	/* Update Open message specific fields */
+	memcpy(acct_msg->data.open_d.ac_path, res->path, PATH_MAX);
+	acct_msg->data.open_d.ac_mode = o_flags;
+	acct_msg->data.open_d.ac_errno = err;
+
+	/* Add to queue */
+	TAILQ_INSERT_TAIL(&head, acct_msg, entries);
+	rw_exit_read(&rwl);
+
+	/* Wake up read, incase it was blocked */
+	wakeup(&head);
+	return;
+}
+
+
+bool
+acct_this_message(uint32_t f_conds, uint32_t o_flags, int err)
+{
+	if (acct_mode_ok(f_conds, err) && acct_conds_ok(f_conds, o_flags))
+		return true;
+
+	return false;
+}
+
+bool 
+acct_conds_ok(uint32_t f_conds, uint32_t o_flags) 
+{
+	if (((f_conds & ACCT_COND_READ) == 0) && ((f_conds & ACCT_COND_WRITE) == 0)) 
+		return false;			/* R/W not set */
+	
+
+	if ((f_conds & ACCT_COND_READ) && (f_conds & ACCT_COND_WRITE)) 
+		return true;			/* R/W both set*/
+	
+
+	if ((f_conds & ACCT_COND_READ) && (((o_flags == O_RDONLY)) || (o_flags & O_RDWR))) 
+		return true;			/* Read set, oflags match, O_RDONLY = 0x00 */
+	
+
+	if ((f_conds & ACCT_COND_WRITE) && ((o_flags & O_WRONLY) || (o_flags & O_RDWR))) 
+		return true;			/* Write set, oflages match */
+	
+
+	return false; 
+}
+
+bool
+acct_mode_ok(uint32_t f_conds, int err) 
+{
+	if ((f_conds & ACCT_COND_SUCCESS) && (f_conds & ACCT_COND_FAILURE)) 
+		return true;			/* Account both failed/succeeded messages */
+	
+
+	if (((f_conds & ACCT_COND_SUCCESS) == 0) && ((f_conds & ACCT_COND_FAILURE) == 0)) 
+		return false;			/* No succes/fail set, dont account */
+	
+
+	if ((f_conds & ACCT_COND_SUCCESS) && (err == 0)) 
+		return true;		/* Success  set, no error */
+	
+	
+
+	if ((f_conds & ACCT_COND_FAILURE) && (err != 0)) 
+		return true;		/* Failure set and error, OK */	
+	
+	return false;
+}
+
+void nuke_the_message_list(void) 
+{
+    struct message *acct_msg;
+
+    while ((acct_msg = TAILQ_FIRST(&head))) {
+	    TAILQ_REMOVE(&head, acct_msg, entries);
+	    free(acct_msg, M_DEVBUF, sizeof(struct message));
+    }
+}
+
+int
+acctclose(dev_t dev, int flag, int mode, struct proc *p)
+{
+	rw_enter_write(&rwl); 
+	sequence_num = 0;
+	device_opened = 0;
+
+    	/* Wipe any remaining messages */
+    	nuke_the_message_list();
+	rw_exit_write(&rwl);
+
+	return 0;
+}
+
+
+int
+acctwrite(dev_t dev, struct uio *uio, int flags)
+{
+	return EOPNOTSUPP;	
+}
+
+
+int 
+acctpoll(dev_t dev, int events, struct proc *p)
+{
+	return POLLERR;
+}
+
+int
+acctkqfilter(dev_t dev, struct knote *kn)
+{
+	return EOPNOTSUPP;
+}
\ No newline at end of file
Index: acct.h
===================================================================
RCS file: acct.h
diff -N acct.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ acct.h	21 Sep 2021 13:05:40 -0000
@@ -0,0 +1,217 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2021 The University of Queensland
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/types.h>
+#include <sys/syslimits.h>
+#include <sys/ioccom.h>
+
+#ifndef __DEV_ACCT_H__
+#define __DEV_ACCT_H__
+
+#define ACCT_MSG_FORK	0
+#define ACCT_MSG_EXEC	1
+#define ACCT_MSG_EXIT	2
+#define	ACCT_MSG_OPEN	3
+#define	ACCT_MSG_RENAME	4
+#define	ACCT_MSG_UNLINK	5
+#define	ACCT_MSG_CLOSE	6
+
+struct acct_common {
+	unsigned short		ac_type;
+	unsigned short		ac_len;
+	unsigned int		ac_seq;
+
+	char			ac_comm[16];	/* command name */
+	struct timespec		ac_etime;	/* elapsed time */
+	struct timespec		ac_btime;	/* starting time */
+	pid_t			ac_pid;		/* process id */
+	uid_t			ac_uid;		/* user id */
+	gid_t			ac_gid;		/* group id */
+	dev_t			ac_tty;		/* controlling tty */
+	unsigned int		ac_flag;	/* accounting flags */
+};
+
+/*
+ * fork info is mostly from the parent, but acct_fork gets passed the child.
+ */
+struct acct_fork {
+	struct acct_common	ac_common;
+	pid_t			ac_cpid;	/* child pid */
+};
+
+/*
+ * exec exists mostly to show the new command name.
+ */
+struct acct_exec {
+	struct acct_common	ac_common;
+};
+
+/*
+ * basically a clone of the ACCOUNTING syscall
+ */
+struct acct_exit {
+	struct acct_common	ac_common;
+	struct timespec		ac_utime;	/* user time */
+	struct timespec		ac_stime;	/* system time */
+	uint64_t		ac_mem;		/* average memory usage */
+	uint64_t		ac_io;		/* count of IO blocks */
+};
+
+/*
+ * generated when a process opens a marked file
+ */
+struct acct_open {
+	struct acct_common	ac_common;
+	char			ac_path[PATH_MAX];
+	int			ac_mode;	/* O_RDONLY | O_WRONLY */
+	int			ac_errno;	/* 0 = success */
+};
+
+struct acct_rename {
+	struct acct_common	ac_common;
+	char			ac_path[PATH_MAX];
+	char			ac_new[PATH_MAX];
+	int			ac_errno;
+};
+
+struct acct_unlink {
+	struct acct_common	ac_common;
+	char			ac_path[PATH_MAX];
+	int			ac_errno;
+};
+
+struct acct_close {
+	struct acct_common	ac_common;
+	char			ac_path[PATH_MAX];
+};
+
+
+#define	ACCT_ENA_FORK		(1 << 0)
+#define	ACCT_ENA_EXEC		(1 << 1)
+#define	ACCT_ENA_EXIT		(1 << 2)
+#define	ACCT_ENA_OPEN		(1 << 3)
+#define	ACCT_ENA_CLOSE		(1 << 4)
+#define	ACCT_ENA_RENAME		(1 << 5)
+#define	ACCT_ENA_UNLINK		(1 << 6)
+#define	ACCT_ENA_ALL		ACCT_ENA_FORK | \
+				ACCT_ENA_EXEC | \
+				ACCT_ENA_EXIT | \
+				ACCT_ENA_OPEN | \
+				ACCT_ENA_CLOSE | \
+				ACCT_ENA_RENAME | \
+				ACCT_ENA_UNLINK
+
+#define	ACCT_COND_READ		(1 << 0)
+#define	ACCT_COND_WRITE		(1 << 1)
+#define	ACCT_COND_SUCCESS	(1 << 2)
+#define	ACCT_COND_FAILURE	(1 << 3)
+#define	ACCT_COND_ALL		ACCT_COND_READ | \
+				ACCT_COND_WRITE | \
+				ACCT_COND_SUCCESS | \
+				ACCT_COND_FAILURE
+
+/*
+ * Common structure for all of the acct ioctls.
+ */
+struct acct_ctl {
+	uint32_t		acct_ena;		/* ACCT_ENA_* */
+	uint32_t		acct_cond;		/* ACCT_COND_* */
+	uint64_t		acct_fcount;		/* count of files */
+	char			acct_path[PATH_MAX];
+};
+
+/*
+ * Gets the global enabled auditing features.
+ *
+ * Output fields: acct_ena, acct_fcount
+ */
+#define	ACCT_IOC_STATUS		_IOR('j', 1, struct acct_ctl)
+
+/*
+ * Gets the set of enabled events and conditions applied to a particular
+ * file (if any). Returns ENOENT if the file is not being tracked.
+ *
+ * Input fields: acct_path
+ * Output fields: acct_ena, acct_cond
+ */
+#define	ACCT_IOC_FSTATUS	_IOWR('j', 2, struct acct_ctl)
+
+/*
+ * Enables audit features globally.
+ *
+ * Input fields: acct_ena (just the features to enable)
+ * Output fields: acct_ena (all currently enabled features after applying)
+ */
+#define	ACCT_IOC_ENABLE		_IOWR('j', 3, struct acct_ctl)
+
+/*
+ * Disables audit features globally.
+ *
+ * Input fields: acct_ena (just the features to disable)
+ * Output fields: acct_ena (all currently enabled features after applying)
+ */
+#define	ACCT_IOC_DISABLE	_IOWR('j', 4, struct acct_ctl)
+
+/*
+ * Starts tracking a file and generating audit events about it. The file must
+ * exist at the specified path when this ioctl is called (if it doesn't, it
+ * returns ENOENT).
+ *
+ * If the file specified is already being tracked, will add to the existing
+ * events/conditions. Returns the final set of events/conditions for this file
+ * in the struct.
+ *
+ * Input fields: acct_ena, acct_cond, acct_path
+ * Output fields: acct_ena, acct_cond
+ */
+#define	ACCT_IOC_TRACK_FILE	_IOWR('j', 5, struct acct_ctl)
+
+/*
+ * Stops tracking a file for audit. The file must exist at the specified path.
+ *
+ * Removes all of the events and conditions specified from the tracking entry
+ * for the file. If no events/conditions are left, the tracking should be
+ * stopped altogether (and 0 returned in both acct_ena and acct_cond).
+ * Otherwise, any remaining events/conditions should be returned.
+ *
+ * Use ACCT_ENA_ALL/ACCT_COND_ALL if you need to completely stop tracking of
+ * a file.
+ *
+ * Input fields: acct_ena, acct_cond, acct_path
+ * Output fields: acct_ena, acct_cond
+ */
+#define	ACCT_IOC_UNTRACK_FILE	_IOWR('j', 6, struct acct_ctl)
+
+
+
+#ifdef _KERNEL
+
+/* Process accounting hooks: leave these alone. */
+void	acct_fork(struct process *);
+void	acct_exec(struct process *);
+void	acct_exit(struct process *);
+
+/* File accounting hooks: you can change these if you want to. */
+void	acct_open(struct process *, struct vnode *, int, int);
+void	acct_rename(struct process *, struct vnode *, const char *, int);
+void	acct_unlink(struct process *, struct vnode *, int);
+void	acct_close(struct process *, struct vnode *, u_int);
+
+#endif /* _KERNEL */
+
+#endif /* __DEV_ACCT_H__ */
